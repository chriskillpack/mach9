# Mach-9

A tool to convert Mach-O object files into Plan 9 assembler formatted output.

To use, first write some assembly and run it through your favorite assembler with debug info included

```
$ cat add_arm64.asm
// To assemble:
//   as add_arm64.asm -g -o add_arm64.o

.global armadd

// func armadd(a, b int) int
//m9: 路armadd(SB),NOSPLIT,$0-24
armadd:
    ldr x0, [x29, #16]  // a
    ldr x1, [x29, #24]  // b
    add x0, x0, x1
    str x0, [x29, #32]  // result
    ret

$ as -g -o add_arm64.o add_arm64.asm
```

Then pass the assembled object file to `mach9`:

```
$ mach9 add_arm64.o | tee add_arm64.s
/*
 * Generated by mach9 add_arm64.o; DO NOT EDIT.
 */

#include "textflag.h"

TEXT 路armadd(SB),NOSPLIT,$0-24
	WORD $0xf9400ba0 // ldr x0, [x29, #16]
	WORD $0xf9400fa1 // ldr x1, [x29, #24]
	WORD $0x8b010000 // add x0, x0, x1
	WORD $0xf90013a0 // str x0, [x29, #32]
	WORD $0xd65f03c0 // ret
```

The output is a valid Plan9 assembly file that contains the assembled code as
byte sequence. To complete the example, the Go code below when built for ARM64
platform will include and execute the generated file and print 30 to stdout.

```
package main

import "fmt"

func armadd(a, b int) int

func main() {
	fmt.Println(armadd(10, 20))
}
```

## m9 Directive

`mach9` is unable to generate a valid Plan9 assembly file from the object file and debug data alone. It requires additional data, namely the function declaration and stack setup, which are provided via an `m9:` directive. This directive must appear on the line immediately preceeding every public symbol. If the line is missing or empty then mach9 will exit with an error.

Everything after the directive until the end of the line is placed into the output function definition. No validation or checking is performed. So the declaration `m9: horses路count,NOSPLIT,$0` will generate output `TEXT horses路count,NOSPLIT,$0`.

See [A Quick Guide to Go's Assembler](https://go.dev/doc/asm#directives) for more details on the supported assembler directives.

## Motivation

For another project I wanted to implement some Go functions in ARM assembly using the NEON instruction extensions (SIMD instruction set), which are not supported by Go Assembler's Intermediate Language. The solution is to use an assembler that does support the extensions and to convert the object code into literal sequences that the Go Assembler will accept.

## TODO

- Resolve questions about platform endianness
- Verify issue about padding when using WORD, does this affect other platforms?
- Investigate why DWARF labels drop _ prefix from symbols. C thing?
- Support additional segments, e.g. data.
