# Mach-9

A tool to convert Mach-O object files into Plan 9 assembler formatted output.

To use, first write some assembly and run it through your favorite assembler with debug info included

```
$ cat hello.asm
// Assemble with
//   as hello.asm -g -o hello.o

.global party, visible
.align 2

//m9: ·party(SB),NOSPLIT,$0-32
party:
    ldr x0, [sp, #8]    ; this is a comment
    ldr x1, [sp, #16]   // also a comment
    add x0, x0, x1
    ret

local:
    mov x0, #1

//m9: ·visible(SB),NOSPLIT,$0
visible:
    mov x0, #2

$ as -g -o hello.o hello.asm
```

Then pass the assembled object file to `mach9`:

```
$ mach9 hello.o | tee hello_arm.s
/*
 * Generated by mach9 hello.o; DO NOT EDIT.
 */

#include "textflag.h"

TEXT ·party(SB),NOSPLIT,$0-32
	WORD $0xf94007e0 // ldr x0, [sp, #8]
	WORD $0xf9400be1 // ldr x1, [sp, #16]
	WORD $0x8b010000 // add x0, x0, x1
	WORD $0xd65f03c0 // ret

TEXT ·visible(SB),NOSPLIT,$0
	WORD $0xd2800040 // mov x0, #2
```

The output is a valid Plan9 assembly file that contains the assembled code as
byte sequence.

## m9 Directive

`mach9` is unable to generate a valid Plan9 assembly file from the object file and debug data alone. It requires additional data, namely the function declaration and stack setup, which are provided via an `m9:` directive. This directive must appear on the line immediately preceeding every public symbol. If the line is missing or empty then mach9 will exit with an error.

Everything after the directive until the end of the line is placed into the output function definition. No validation or checking is performed. So the declaration `m9: horses·count,NOSPLIT,$0` will generate output `TEXT horses·count,NOSPLIT,$0`.

See [A Quick Guide to Go's Assembler](https://go.dev/doc/asm#directives) for more details on the supported assembler directives.

## Motivation

For another project I wanted to implement some Go functions in ARM assembly using the NEON instruction extensions (SIMD instruction set), which are not supported by Go Assembler's Intermediate Language. The solution is to use an assembler that does support the extensions and to convert the object code into literal sequences that the Go Assembler will accept.

## TODO

- Resolve questions about platform endianness
- Verify issue about padding when using WORD, does this affect other platforms?
- Investigate why DWARF labels drop _ prefix from symbols. C thing?
- Support additional segments, e.g. data.
